<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        /* ä¸»å®¹å™¨ */
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Canvasæ¸²æŸ“åŒºåŸŸ */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* è§†é¢‘æ•è·åŒºåŸŸ */
        #video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            z-index: 2;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        #video:hover {
            opacity: 1;
        }

        /* ç…§ç‰‡ä¸Šä¼ åŒºåŸŸ */
        .upload-section {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .upload-btn {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        #file-input {
            display: none;
        }

        .upload-info {
            margin-top: 10px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* çŠ¶æ€æŒ‡ç¤º */
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-closed {
            color: #4ecdc4;
            border: 2px solid #4ecdc4;
        }

        .status-scattered {
            color: #45b7d1;
            border: 2px solid #45b7d1;
        }

        .status-zoom {
            color: #f9ca24;
            border: 2px solid #f9ca24;
        }

        /* æç¤ºä¿¡æ¯ */
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 2;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 300px;
            line-height: 1.5;
        }

        .instructions h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .instructions ul {
            list-style: none;
        }

        .instructions li {
            margin-bottom: 5px;
            color: rgba(255, 255, 255, 0.8);
        }

        /* è¾‰å…‰æ•ˆæœ */
        .glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 0, 0, 0.1) 50%, transparent 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            filter: blur(50px);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.5;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.8;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- è¾‰å…‰æ•ˆæœ -->
        <div class="glow"></div>
        
        <!-- Canvasæ¸²æŸ“åŒºåŸŸ -->
        <canvas id="canvas"></canvas>
        
        <!-- è§†é¢‘æ•è·åŒºåŸŸ -->
        <video id="video" autoplay playsinline></video>
        
        <!-- ç…§ç‰‡ä¸Šä¼ åŒºåŸŸ -->
        <div class="upload-section">
            <button class="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ ç…§ç‰‡</button>
            <input type="file" id="file-input" accept="image/*" multiple>
            <div class="upload-info" id="upload-info">æ”¯æŒå¤šå¼ ç…§ç‰‡ä¸Šä¼ </div>
        </div>
        
        <!-- çŠ¶æ€æŒ‡ç¤º -->
        <div class="status-indicator status-closed" id="status-indicator">åˆæ‹¢æ€</div>
        
        <!-- æ“ä½œæç¤º -->
        <div class="instructions">
            <h3>æ‰‹åŠ¿æ“ä½œè¯´æ˜</h3>
            <ul>
                <li>âœŠ æ¡æ‹³ï¼šå›åˆ°åˆæ‹¢æ€</li>
                <li>ğŸ–ï¸ äº”æŒ‡å¼ å¼€ï¼šè¿›å…¥æ•£å¼€æ€</li>
                <li>ğŸ”„ æ‰‹æ—‹è½¬ï¼šè°ƒæ•´ç›¸æœºè§’åº¦</li>
                <li>ğŸ¤ æŠ“å–ï¼šæ”¾å¤§å•å¼ ç…§ç‰‡</li>
            </ul>
        </div>
    </div>

    <!-- å¼•å…¥Three.js - ä½¿ç”¨æ­£ç¡®çš„CDNé“¾æ¥ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    
    <!-- å¼•å…¥MediaPipe Hands - ä½¿ç”¨å¤‡ç”¨CDN -->
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils@0.3/drawing_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4/hands.js"></script>
    
    <script>
        // ä¸»åº”ç”¨ç¨‹åºç±»
        class ChristmasTreeApp {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.video = document.getElementById('video');
                this.fileInput = document.getElementById('file-input');
                this.statusIndicator = document.getElementById('status-indicator');
                this.uploadInfo = document.getElementById('upload-info');
                
                // åº”ç”¨çŠ¶æ€
                this.state = 'closed'; // closed, scattered, zoomed
                this.targetState = 'closed'; // ç›®æ ‡çŠ¶æ€ï¼Œç”¨äºå¹³æ»‘è¿‡æ¸¡
                this.transitionProgress = 0; // è¿‡æ¸¡è¿›åº¦ï¼š0-1
                this.isTransitioning = false; // æ˜¯å¦æ­£åœ¨è¿‡æ¸¡
                this.transitionDuration = 1000; // è¿‡æ¸¡æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                this.transitionStart = 0; // è¿‡æ¸¡å¼€å§‹æ—¶é—´
                
                this.hands = null;
                this.camera = null;
                this.scene = null;
                this.renderer = null;
                this.particles = [];
                this.photos = [];
                this.uploadedImages = [];
                
                // æ‰‹åŠ¿çŠ¶æ€
                this.handPosition = { x: 0, y: 0, z: 0 };
                this.handRotation = { x: 0, y: 0, z: 0 };
                this.isFist = false;
                this.isOpenHand = false;
                this.isGrabbing = false;
                
                // åˆå§‹åŒ–åº”ç”¨
                this.init();
            }
            
            /**
             * åˆå§‹åŒ–åº”ç”¨ç¨‹åº
             * åŒ…æ‹¬Three.jsåœºæ™¯ã€MediaPipe Handså’Œäº‹ä»¶ç›‘å¬
             */
            init() {
                // åˆå§‹åŒ–Three.jsåœºæ™¯
                this.initThreeJS();
                
                // åˆå§‹åŒ–MediaPipe Hands
                this.initMediaPipe();
                
                // è®¾ç½®äº‹ä»¶ç›‘å¬
                this.setupEventListeners();
                
                // å¼€å§‹æ¸²æŸ“å¾ªç¯
                this.animate();
            }
            
            /**
             * åˆå§‹åŒ–Three.jsåœºæ™¯
             */
            initThreeJS() {
                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);
                
                // åˆ›å»ºç›¸æœº
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 0, 15);
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // æ·»åŠ å…‰æº
                this.addLights();
                
                // åˆ›å»ºåœ£è¯æ ‘å…ƒç´ 
                this.createChristmasTreeElements();
                
                // å¤„ç†çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => this.onWindowResize());
                

            }
            

            
            /**
             * æ·»åŠ åœºæ™¯å…‰æº
             */
            addLights() {
                // ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // ä¸»å…‰æº
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(5, 10, 7.5);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                this.scene.add(mainLight);
                
                // é‡‘è‰²ç‚¹å…‰æº
                const goldLight = new THREE.PointLight(0xffd700, 1, 100);
                goldLight.position.set(0, 5, 0);
                this.scene.add(goldLight);
                
                // çº¢è‰²ç‚¹å…‰æº
                const redLight = new THREE.PointLight(0xff0000, 0.5, 50);
                redLight.position.set(-5, 0, 5);
                this.scene.add(redLight);
                
                // ç»¿è‰²ç‚¹å…‰æº
                const greenLight = new THREE.PointLight(0x00ff00, 0.3, 50);
                greenLight.position.set(5, 0, -5);
                this.scene.add(greenLight);
            }
            
            /**
             * åˆ›å»ºåœ£è¯æ ‘å…ƒç´ 
             */
            createChristmasTreeElements() {
                // åˆ›å»ºç²’å­ç³»ç»Ÿ
                this.createParticles();
                
                // åˆ›å»ºç…§ç‰‡äº‘
                this.createPhotoCloud();
            }
            
            /**
             * åˆ›å»ºç²’å­ç³»ç»Ÿ - ç¡®ä¿å½¢æˆæ­£ç¡®çš„åœ£è¯æ ‘å½¢çŠ¶
             */
            createParticles() {
                const particleCount = 300;
                
                // ä½¿ç”¨å¸¦æœ‰å‘å°„å…‰çš„æè´¨ï¼Œå¢å¼ºè§†è§‰æ•ˆæœ
                const materials = [
                    new THREE.MeshPhongMaterial({ 
                        color: 0x228B22, // å“‘å…‰ç»¿
                        emissive: 0x114411,
                        shininess: 30
                    }),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xFFD700, // é‡‘å±é‡‘
                        emissive: 0x443300,
                        shininess: 100
                    }),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xFF6B6B, // åœ£è¯çº¢
                        emissive: 0x441111,
                        shininess: 50
                    })
                ];
                
                // å½¢çŠ¶æ•°ç»„
                const shapeGeometries = [
                    new THREE.SphereGeometry(0.15, 8, 8),      // çƒ
                    new THREE.BoxGeometry(0.2, 0.2, 0.2),   // æ­£æ–¹ä½“
                    new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8) // ç³–æœæ£
                ];
                
                this.particles = [];
                
                // åœ£è¯æ ‘å±‚æ•°ï¼Œæ¯å±‚æ”¾ç½®ä¸åŒæ•°é‡çš„ç²’å­
                const treeLevels = 10;
                
                // é€å±‚åˆ›å»ºç²’å­ï¼Œç¡®ä¿å½¢æˆåœ†é”¥ä½“
                for (let level = 0; level < treeLevels; level++) {
                    // è®¡ç®—å½“å‰å±‚çš„é«˜åº¦å’ŒåŠå¾„
                    // é«˜åº¦ä»åº•éƒ¨(-4)åˆ°é¡¶éƒ¨(2)
                    const height = (level / treeLevels) * 6 - 4;
                    
                    // åŠå¾„ä»åº•éƒ¨(4)åˆ°é¡¶éƒ¨(0.5)ï¼Œä½¿ç”¨å¹³æ–¹å‡½æ•°ä½¿å½¢çŠ¶æ›´è‡ªç„¶
                    const radius = Math.max(0.5, 4 - (level / treeLevels) * 4);
                    
                    // æ¯å±‚ç²’å­æ•°é‡ï¼Œåº•éƒ¨å¤šï¼Œé¡¶éƒ¨å°‘
                    const particlesPerLevel = Math.floor(particleCount * (1 - level / treeLevels) / treeLevels * 3);
                    
                    // åœ¨å½“å‰å±‚åˆ›å»ºç²’å­
                    for (let i = 0; i < particlesPerLevel; i++) {
                        // éšæœºé€‰æ‹©å½¢çŠ¶å’Œæè´¨
                        const shapeIndex = Math.floor(Math.random() * shapeGeometries.length);
                        const materialIndex = Math.floor(Math.random() * materials.length);
                        
                        const geometry = shapeGeometries[shapeIndex];
                        const material = materials[materialIndex];
                        
                        const particle = new THREE.Mesh(geometry, material);
                        
                        // éšæœºè§’åº¦ï¼Œç¡®ä¿3Dåˆ†å¸ƒ
                        const angle = Math.random() * Math.PI * 2;
                        
                        // æ·»åŠ ä¸€äº›éšæœºåŠå¾„å˜åŒ–ï¼Œä½¿å½¢çŠ¶æ›´è‡ªç„¶
                        const randomRadius = radius * (0.7 + Math.random() * 0.6);
                        
                        // 2Dåœ†å½¢åˆ†å¸ƒï¼Œç®€å•å¯é 
                        const x = Math.cos(angle) * randomRadius;
                        const z = Math.sin(angle) * randomRadius;
                        
                        // è®¾ç½®ç²’å­ä½ç½®
                        particle.position.set(x, height, z);
                        
                        // è®¾ç½®éšæœºæ—‹è½¬
                        particle.rotation.set(
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 2
                        );
                        
                        // æ·»åŠ åˆ°åœºæ™¯
                        this.scene.add(particle);
                        
                        // ä¿å­˜ç²’å­æ•°æ®
                        this.particles.push({
                            mesh: particle,
                            originalPosition: particle.position.clone(),
                            scatteredPosition: new THREE.Vector3(
                                (Math.random() - 0.5) * 20,
                                (Math.random() - 0.5) * 20,
                                (Math.random() - 0.5) * 20
                            ),
                            speed: {
                                x: (Math.random() - 0.5) * 0.02,
                                y: (Math.random() - 0.5) * 0.02,
                                z: (Math.random() - 0.5) * 0.02
                            },
                            rotationSpeed: {
                                x: (Math.random() - 0.5) * 0.01,
                                y: (Math.random() - 0.5) * 0.01,
                                z: (Math.random() - 0.5) * 0.01
                            }
                        });
                    }
                }
            }
            
            /**
             * åˆ›å»ºç…§ç‰‡äº‘
             */
            createPhotoCloud() {
                const photoCount = 20;
                
                for (let i = 0; i < photoCount; i++) {
                    // åˆ›å»ºåŸºç¡€ç…§ç‰‡å‡ ä½•ä½“
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    
                    // é»˜è®¤æè´¨
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const photo = new THREE.Mesh(geometry, material);
                    
                    // åˆå§‹ä½ç½®ï¼ˆåˆæ‹¢æ€ï¼‰
                    const angle = Math.random() * Math.PI * 2;
                    const height = Math.random() * 10 - 5;
                    const radius = Math.sqrt(10 - height * 0.5);
                    
                    photo.position.set(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );
                    
                    photo.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                    
                    photo.castShadow = true;
                    photo.receiveShadow = true;
                    
                    this.scene.add(photo);
                    
                    // ä¿å­˜ç…§ç‰‡åˆå§‹çŠ¶æ€
                    this.photos.push({
                        mesh: photo,
                        originalPosition: photo.position.clone(),
                        scatteredPosition: new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        ),
                        originalScale: photo.scale.clone(),
                        speed: {
                            x: (Math.random() - 0.5) * 0.01,
                            y: (Math.random() - 0.5) * 0.01,
                            z: (Math.random() - 0.5) * 0.01
                        },
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.005,
                            y: (Math.random() - 0.5) * 0.005,
                            z: (Math.random() - 0.5) * 0.005
                        },
                        hasImage: false
                    });
                }
            }
            
            /**
             * åˆå§‹åŒ–MediaPipe Hands
             */
            initMediaPipe() {
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
                    }
                });
                
                // é…ç½®Handsæ¨¡å‹
                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.7
                });
                
                // è®¾ç½®ç»“æœå›è°ƒ
                this.hands.onResults((results) => this.onHandResults(results));
                
                // å¯åŠ¨ç›¸æœº
                this.startCamera();
            }
            
            /**
             * å¯åŠ¨ç›¸æœº
             */
            async startCamera() {
                try {
                    // é¦–å…ˆè¯·æ±‚ç›¸æœºæƒé™
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 640, height: 480 }
                    });
                    
                    // è®¾ç½®è§†é¢‘æµ
                    this.video.srcObject = stream;
                    this.video.onloadedmetadata = () => {
                        this.video.play();
                        
                        // åˆå§‹åŒ–MediaPipeç›¸æœº
                        const camera = new Camera(this.video, {
                            onFrame: async () => {
                                if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                                    await this.hands.send({ image: this.video });
                                }
                            },
                            width: 640,
                            height: 480
                        });
                        camera.start();
                    };
                } catch (error) {
                    console.error('ç›¸æœºè®¿é—®å¤±è´¥:', error);
                    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                    this.showCameraError();
                }
            }
            
            /**
             * æ˜¾ç¤ºç›¸æœºé”™è¯¯ä¿¡æ¯
             */
            showCameraError() {
                // åˆ›å»ºé”™è¯¯æç¤ºå…ƒç´ 
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 1000;
                    font-family: Arial, sans-serif;
                `;
                errorDiv.innerHTML = `
                    <h3>ç›¸æœºè®¿é—®å¤±è´¥</h3>
                    <p>è¯·æ£€æŸ¥ï¼š</p>
                    <ul style="text-align: left; margin: 10px 0;">
                        <li>1. æ‚¨æ˜¯å¦å…è®¸äº†ç›¸æœºæƒé™ï¼Ÿ</li>
                        <li>2. è®¾å¤‡ä¸Šæ˜¯å¦æœ‰å¯ç”¨çš„ç›¸æœºï¼Ÿ</li>
                        <li>3. ç›¸æœºæ˜¯å¦è¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Ÿ</li>
                    </ul>
                    <p>åº”ç”¨å°†ç»§ç»­è¿è¡Œï¼Œä½†æ‰‹åŠ¿æ§åˆ¶åŠŸèƒ½ä¸å¯ç”¨ã€‚</p>
                    <button onclick="this.parentElement.remove()" style="
                        margin-top: 10px;
                        padding: 8px 16px;
                        background: white;
                        color: red;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                    ">å…³é—­</button>
                `;
                
                document.body.appendChild(errorDiv);
            }
            
            /**
             * å¤„ç†æ‰‹åŠ¿æ£€æµ‹ç»“æœ
             * @param {Object} results - MediaPipe Handsæ£€æµ‹ç»“æœ
             */
            onHandResults(results) {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    return;
                }
                
                const landmarks = results.multiHandLandmarks[0];
                
                // æ£€æµ‹æ‰‹åŠ¿
                this.detectGestures(landmarks);
                
                // æ›´æ–°æ‰‹çš„ä½ç½®å’Œæ—‹è½¬
                this.updateHandPosition(landmarks);
            }
            
            /**
             * æ£€æµ‹æ‰‹åŠ¿
             * @param {Array} landmarks - æ‰‹éƒ¨å…³é”®ç‚¹æ•°ç»„
             */
            detectGestures(landmarks) {
                // æ£€æµ‹æ¡æ‹³
                this.isFist = this.isFistGesture(landmarks);
                
                // æ£€æµ‹äº”æŒ‡å¼ å¼€
                this.isOpenHand = this.isOpenHandGesture(landmarks);
                
                // æ£€æµ‹æŠ“å–åŠ¨ä½œ
                this.isGrabbing = this.isGrabbingGesture(landmarks);
                
                // æ ¹æ®æ‰‹åŠ¿æ›´æ–°çŠ¶æ€
                this.updateStateFromGestures();
            }
            
            /**
             * åˆ¤æ–­æ˜¯å¦ä¸ºæ¡æ‹³æ‰‹åŠ¿
             * @param {Array} landmarks - æ‰‹éƒ¨å…³é”®ç‚¹æ•°ç»„
             * @returns {boolean} - æ˜¯å¦ä¸ºæ¡æ‹³æ‰‹åŠ¿
             */
            isFistGesture(landmarks) {
                // ç®€å•çš„æ¡æ‹³æ£€æµ‹ï¼šæ‰‹æŒ‡å°–æ˜¯å¦é è¿‘æ‰‹æŒ
                const fingerTips = [8, 12, 16, 20];
                const palmCenter = landmarks[9];
                
                let closedFingers = 0;
                for (const tip of fingerTips) {
                    const distance = Math.sqrt(
                        Math.pow(landmarks[tip].x - palmCenter.x, 2) +
                        Math.pow(landmarks[tip].y - palmCenter.y, 2) +
                        Math.pow(landmarks[tip].z - palmCenter.z, 2)
                    );
                    
                    if (distance < 0.1) {
                        closedFingers++;
                    }
                }
                
                return closedFingers >= 3;
            }
            
            /**
             * åˆ¤æ–­æ˜¯å¦ä¸ºäº”æŒ‡å¼ å¼€æ‰‹åŠ¿
             * @param {Array} landmarks - æ‰‹éƒ¨å…³é”®ç‚¹æ•°ç»„
             * @returns {boolean} - æ˜¯å¦ä¸ºäº”æŒ‡å¼ å¼€æ‰‹åŠ¿
             */
            isOpenHandGesture(landmarks) {
                // ç®€å•çš„å¼ å¼€æ‰‹æ£€æµ‹ï¼šæ‰‹æŒ‡å°–æ˜¯å¦è¿œç¦»æ‰‹æŒ
                const fingerTips = [8, 12, 16, 20];
                const palmCenter = landmarks[9];
                
                let openFingers = 0;
                for (const tip of fingerTips) {
                    const distance = Math.sqrt(
                        Math.pow(landmarks[tip].x - palmCenter.x, 2) +
                        Math.pow(landmarks[tip].y - palmCenter.y, 2) +
                        Math.pow(landmarks[tip].z - palmCenter.z, 2)
                    );
                    
                    if (distance > 0.15) {
                        openFingers++;
                    }
                }
                
                return openFingers >= 4;
            }
            
            /**
             * åˆ¤æ–­æ˜¯å¦ä¸ºæŠ“å–æ‰‹åŠ¿
             * @param {Array} landmarks - æ‰‹éƒ¨å…³é”®ç‚¹æ•°ç»„
             * @returns {boolean} - æ˜¯å¦ä¸ºæŠ“å–æ‰‹åŠ¿
             */
            isGrabbingGesture(landmarks) {
                // æŠ“å–æ‰‹åŠ¿ï¼šæ‰‹æŒ‡éƒ¨åˆ†å¼¯æ›²
                const fingerTips = [8, 12, 16, 20];
                const fingerMCPs = [5, 9, 13, 17];
                
                let grabbingFingers = 0;
                for (let i = 0; i < fingerTips.length; i++) {
                    const tip = landmarks[fingerTips[i]];
                    const mcp = landmarks[fingerMCPs[i]];
                    const pip = landmarks[fingerMCPs[i] + 1];
                    
                    // è®¡ç®—æ‰‹æŒ‡å¼¯æ›²ç¨‹åº¦
                    const vector1 = new THREE.Vector3(tip.x - pip.x, tip.y - pip.y, tip.z - pip.z);
                    const vector2 = new THREE.Vector3(pip.x - mcp.x, pip.y - mcp.y, pip.z - mcp.z);
                    
                    const angle = vector1.angleTo(vector2);
                    
                    if (angle > 1.0) { // å¼¯æ›²è§’åº¦å¤§äº60åº¦
                        grabbingFingers++;
                    }
                }
                
                return grabbingFingers >= 2;
            }
            
            /**
             * æ›´æ–°æ‰‹çš„ä½ç½®å’Œæ—‹è½¬
             * @param {Array} landmarks - æ‰‹éƒ¨å…³é”®ç‚¹æ•°ç»„
             */
            updateHandPosition(landmarks) {
                // è®¡ç®—æ‰‹çš„ä¸­å¿ƒä½ç½®ï¼ˆä½¿ç”¨æ‰‹è…•å’Œæ‰‹æŒä¸­å¿ƒï¼‰
                const wrist = landmarks[0];
                const palmCenter = landmarks[9];
                
                this.handPosition = {
                    x: (wrist.x + palmCenter.x) / 2,
                    y: (wrist.y + palmCenter.y) / 2,
                    z: (wrist.z + palmCenter.z) / 2
                };
                
                // è®¡ç®—æ‰‹çš„æ—‹è½¬
                // ç®€å•å®ç°ï¼šåŸºäºæ‰‹æŒ‡æ–¹å‘
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                
                const direction = new THREE.Vector3(
                    indexTip.x - thumbTip.x,
                    indexTip.y - thumbTip.y,
                    indexTip.z - thumbTip.z
                );
                
                const quaternion = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(1, 0, 0),
                    direction.normalize()
                );
                
                const euler = new THREE.Euler().setFromQuaternion(quaternion);
                
                this.handRotation = {
                    x: euler.x,
                    y: euler.y,
                    z: euler.z
                };
            }
            
            /**
             * æ ¹æ®æ‰‹åŠ¿æ›´æ–°åº”ç”¨çŠ¶æ€
             */
            updateStateFromGestures() {
                if (this.isFist) {
                    this.setState('closed');
                } else if (this.isOpenHand) {
                    this.setState('scattered');
                } else if (this.isGrabbing && this.state === 'scattered') {
                    this.setState('zoomed');
                }
            }
            
            /**
             * è®¾ç½®åº”ç”¨çŠ¶æ€
             * @param {string} newState - æ–°çŠ¶æ€ï¼šclosed, scattered, zoomed
             */
            setState(newState) {
                if (this.targetState === newState) {
                    return;
                }
                
                this.targetState = newState;
                this.isTransitioning = true;
                this.transitionStart = performance.now();
                this.transitionProgress = 0;
            }
            
            /**
             * æ›´æ–°çŠ¶æ€è¿‡æ¸¡
             */
            updateTransition() {
                if (!this.isTransitioning) {
                    return;
                }
                
                const now = performance.now();
                const elapsed = now - this.transitionStart;
                
                // è®¡ç®—è¿‡æ¸¡è¿›åº¦ï¼ˆ0-1ï¼‰
                this.transitionProgress = Math.min(elapsed / this.transitionDuration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°ä½¿è¿‡æ¸¡æ›´è‡ªç„¶
                const easedProgress = this.easeInOutCubic(this.transitionProgress);
                
                // æ£€æŸ¥è¿‡æ¸¡æ˜¯å¦å®Œæˆ
                if (this.transitionProgress >= 1) {
                    this.state = this.targetState;
                    this.isTransitioning = false;
                    this.transitionProgress = 1;
                    
                    // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                    this.updateStatusIndicator();
                }
            }
            
            /**
             * ç¼“åŠ¨å‡½æ•°ï¼šç¼“å…¥ç¼“å‡º
             * @param {number} t - æ—¶é—´è¿›åº¦ï¼š0-1
             * @returns {number} - ç¼“åŠ¨åçš„è¿›åº¦ï¼š0-1
             */
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
            }
            
            /**
             * æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
             */
            updateStatusIndicator() {
                this.statusIndicator.className = 'status-indicator';
                
                switch (this.state) {
                    case 'closed':
                        this.statusIndicator.classList.add('status-closed');
                        this.statusIndicator.textContent = 'åˆæ‹¢æ€';
                        break;
                    case 'scattered':
                        this.statusIndicator.classList.add('status-scattered');
                        this.statusIndicator.textContent = 'æ•£å¼€æ€';
                        break;
                    case 'zoomed':
                        this.statusIndicator.classList.add('status-zoom');
                        this.statusIndicator.textContent = 'ç…§ç‰‡æ”¾å¤§æ€';
                        break;
                }
            }
            
            /**
             * è®¾ç½®äº‹ä»¶ç›‘å¬
             */
            setupEventListeners() {
                // ç…§ç‰‡ä¸Šä¼ äº‹ä»¶
                this.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
            }
            
            /**
             * å¤„ç†ç…§ç‰‡ä¸Šä¼ 
             * @param {Event} e - æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
             */
            handleFileUpload(e) {
                const files = e.target.files;
                if (files.length === 0) {
                    return;
                }
                
                // æ¸…ç©ºä¹‹å‰çš„ä¸Šä¼ 
                this.uploadedImages = [];
                
                // å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const image = new Image();
                        image.onload = () => {
                            this.uploadedImages.push(image);
                            this.updatePhotoCloud();
                            this.uploadInfo.textContent = `å·²ä¸Šä¼  ${this.uploadedImages.length} å¼ ç…§ç‰‡`;
                        };
                        image.src = event.target.result;
                    };
                    
                    reader.readAsDataURL(file);
                }
            }
            
            /**
             * æ›´æ–°ç…§ç‰‡äº‘ï¼Œå°†ä¸Šä¼ çš„ç…§ç‰‡åº”ç”¨åˆ°3Dæ¨¡å‹ä¸Š
             */
            updatePhotoCloud() {
                for (let i = 0; i < this.photos.length; i++) {
                    if (i < this.uploadedImages.length) {
                        const image = this.uploadedImages[i];
                        const texture = new THREE.Texture(image);
                        texture.needsUpdate = true;
                        
                        this.photos[i].mesh.material.map = texture;
                        this.photos[i].hasImage = true;
                    }
                }
            }
            
            /**
             * æ›´æ–°ç²’å­å’Œç…§ç‰‡çš„ä½ç½®
             * æ ¹æ®å½“å‰çŠ¶æ€è¿›è¡ŒåŠ¨ç”»è¿‡æ¸¡
             */
            updateElements() {
                // æ›´æ–°çŠ¶æ€è¿‡æ¸¡
                this.updateTransition();
                
                // æ›´æ–°æ—¶é—´
                const time = performance.now() * 0.001;
                
                // æ›´æ–°ç²’å­
                for (const particle of this.particles) {
                    this.updateParticle(particle, time);
                }
                
                // æ›´æ–°ç…§ç‰‡
                for (const photo of this.photos) {
                    this.updatePhoto(photo, time);
                }
                
                // æ ¹æ®çŠ¶æ€æ›´æ–°ç›¸æœº
                this.updateCamera();
            }
            
            /**
             * æ›´æ–°å•ä¸ªç²’å­
             * @param {Object} particle - ç²’å­å¯¹è±¡
             * @param {number} time - å½“å‰æ—¶é—´
             */
            updateParticle(particle, time) {
                switch (this.state) {
                    case 'closed':
                        // å›åˆ°åˆæ‹¢æ€
                        particle.mesh.position.lerp(particle.originalPosition, 0.05);
                        break;
                    
                    case 'scattered':
                        // æ•£å¼€æ€ï¼šæ¼‚æµ®æ•ˆæœ
                        particle.mesh.position.lerp(particle.scatteredPosition, 0.02);
                        
                        // æ·»åŠ éšæœºè¿åŠ¨
                        particle.scatteredPosition.x += particle.speed.x;
                        particle.scatteredPosition.y += particle.speed.y;
                        particle.scatteredPosition.z += particle.speed.z;
                        
                        // è¾¹ç•Œæ£€æµ‹
                        if (Math.abs(particle.scatteredPosition.x) > 15) particle.speed.x *= -1;
                        if (Math.abs(particle.scatteredPosition.y) > 15) particle.speed.y *= -1;
                        if (Math.abs(particle.scatteredPosition.z) > 15) particle.speed.z *= -1;
                        break;
                    
                    case 'zoomed':
                        // ç…§ç‰‡æ”¾å¤§æ€ï¼šä¿æŒå½“å‰ä½ç½®
                        break;
                }
                
                // æ›´æ–°æ—‹è½¬
                particle.mesh.rotation.x += particle.rotationSpeed.x;
                particle.mesh.rotation.y += particle.rotationSpeed.y;
                particle.mesh.rotation.z += particle.rotationSpeed.z;
            }
            
            /**
             * æ›´æ–°å•ä¸ªç…§ç‰‡
             * @param {Object} photo - ç…§ç‰‡å¯¹è±¡
             * @param {number} time - å½“å‰æ—¶é—´
             */
            updatePhoto(photo, time) {
                switch (this.state) {
                    case 'closed':
                        // å›åˆ°åˆæ‹¢æ€
                        photo.mesh.position.lerp(photo.originalPosition, 0.05);
                        photo.mesh.scale.lerp(photo.originalScale, 0.05);
                        break;
                    
                    case 'scattered':
                        // æ•£å¼€æ€ï¼šæ¼‚æµ®æ•ˆæœ
                        photo.mesh.position.lerp(photo.scatteredPosition, 0.02);
                        
                        // æ·»åŠ éšæœºè¿åŠ¨
                        photo.scatteredPosition.x += photo.speed.x;
                        photo.scatteredPosition.y += photo.speed.y;
                        photo.scatteredPosition.z += photo.speed.z;
                        
                        // è¾¹ç•Œæ£€æµ‹
                        if (Math.abs(photo.scatteredPosition.x) > 15) photo.speed.x *= -1;
                        if (Math.abs(photo.scatteredPosition.y) > 15) photo.speed.y *= -1;
                        if (Math.abs(photo.scatteredPosition.z) > 15) photo.speed.z *= -1;
                        
                        photo.mesh.scale.lerp(photo.originalScale, 0.05);
                        break;
                    
                    case 'zoomed':
                        // ç…§ç‰‡æ”¾å¤§æ€ï¼šæ”¾å¤§ç¬¬ä¸€å¼ æœ‰å›¾ç‰‡çš„ç…§ç‰‡
                        if (photo.hasImage && this.photos.indexOf(photo) === 0) {
                            photo.mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.05);
                        } else {
                            // å…¶ä»–ç…§ç‰‡ä¿æŒæ•£å¼€æ€
                            photo.mesh.position.lerp(photo.scatteredPosition, 0.02);
                        }
                        break;
                }
                
                // æ›´æ–°æ—‹è½¬
                photo.mesh.rotation.x += photo.rotationSpeed.x;
                photo.mesh.rotation.y += photo.rotationSpeed.y;
                photo.mesh.rotation.z += photo.rotationSpeed.z;
            }
            
            /**
             * æ›´æ–°ç›¸æœºä½ç½®å’Œæ—‹è½¬
             */
            updateCamera() {
                if (this.state === 'scattered') {
                    // æ ¹æ®æ‰‹çš„ç§»åŠ¨è°ƒæ•´ç›¸æœºè§’åº¦
                    const targetX = this.handPosition.x * 10;
                    const targetY = -this.handPosition.y * 10;
                    
                    this.camera.position.x += (targetX - this.camera.position.x) * 0.1;
                    this.camera.position.y += (targetY - this.camera.position.y) * 0.1;
                }
                
                // ç›¸æœºå§‹ç»ˆçœ‹å‘åœºæ™¯ä¸­å¿ƒ
                this.camera.lookAt(0, 0, 0);
            }
            
            /**
             * è®¾ç½®åº”ç”¨çŠ¶æ€
             * @param {string} newState - æ–°çŠ¶æ€
             */
            setState(newState) {
                if (this.state !== newState) {
                    this.state = newState;
                    this.updateStatusIndicator();
                }
            }
            
            /**
             * å¤„ç†çª—å£å¤§å°å˜åŒ–
             */
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            /**
             * åŠ¨ç”»å¾ªç¯
             */
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // æ›´æ–°å…ƒç´ ä½ç½®å’ŒçŠ¶æ€
                this.updateElements();
                
                // æ¸²æŸ“åœºæ™¯
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // åˆå§‹åŒ–åº”ç”¨ - ç¡®ä¿Three.jsåŠ è½½å®Œæˆ
        if (typeof THREE !== 'undefined') {
            // Three.jså·²åŠ è½½ï¼Œç›´æ¥åˆå§‹åŒ–
            console.log('Three.js loaded successfully');
            new ChristmasTreeApp();
        } else {
            // Three.jsæœªåŠ è½½ï¼Œç­‰å¾…ä¸€å°æ®µæ—¶é—´åå†æ¬¡å°è¯•
            setTimeout(() => {
                if (typeof THREE !== 'undefined') {
                    console.log('Three.js loaded successfully');
                    new ChristmasTreeApp();
                } else {
                    console.error('Failed to load Three.js');
                }
            }, 500);
        }
    </script>
</body>
</html>