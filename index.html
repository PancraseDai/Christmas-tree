<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glowing Lights Xmas Tree</title>
    
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #050a08 0%, #000000 100%); font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .header {
            text-align: center;
            color: #fff;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            margin-top: 20px;
        }

        h1 { margin: 0; font-weight: 300; letter-spacing: 6px; text-transform: uppercase; font-size: 1.8rem; color: #D4AF37; }
        p.status { color: #88ccff; font-size: 1rem; margin-top: 5px; font-weight: bold; text-shadow: 0 0 5px rgba(136, 204, 255, 0.6); }

        .controls-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: auto;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .input-group {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #fff;
        }

        #cam-preview {
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border-radius: 12px;
            border: 2px solid #D4AF37;
            opacity: 0.8;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.1);
        }

        .instructions {
            color: #aaa;
            font-size: 0.85rem;
            line-height: 1.6;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 12px;
        }
        .key-point { color: #D4AF37; font-weight: bold; }

        input[type="file"] { display: none; }
        .upload-btn {
            background: linear-gradient(135deg, #444, #222);
            color: white;
            padding: 12px 24px;
            border: 1px solid #666;
            border-radius: 30px;
            cursor: pointer;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: 0.3s;
            display: inline-block;
        }
        .upload-btn:hover { background: #555; border-color: #fff; box-shadow: 0 0 15px rgba(255,255,255,0.3); }

        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #D4AF37; z-index: 100;
            transition: opacity 0.8s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #fff; border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="margin-top:15px; letter-spacing:2px; color:#fff">Lighting the Lights...</div>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>Luminous Christmas</h1>
            <p class="status" id="gesture-status">Waiting for Hand Gesture...</p>
        </div>

        <div class="controls-area">
            <div class="instructions">
                <div><span class="key-point">‚úä Fist:</span> Gather Lights</div>
                <div><span class="key-point">üñê Open Hand:</span> Scatter Stars</div>
                <div><span class="key-point">üëå Pinch:</span> View Memory</div>
            </div>

            <div class="input-group">
                <label class="upload-btn">
                    Upload Photos
                    <input type="file" id="photo-upload" multiple accept="image/*">
                </label>
            </div>

            <video id="cam-preview" playsinline></video>
        </div>
    </div>

    <script>
        // --- Globals ---
        // Â¢ûÂä†‰∫ÜÁ≤íÂ≠êÊï∞ÈáèÔºå‰ΩøÊ†ëÁúãËµ∑Êù•Áî±ÂÖâÁÇπÁªÑÊàê
        const PARTICLE_COUNT = 2500; 
        const SNOW_COUNT = 800; 
        
        // Ë∞ÉÊï¥‰∫ÜÈ¢úËâ≤ÔºåÊõ¥ÂÄæÂêë‰∫éÂÖâËâ≤ (BasicMaterial‰∏çÈúÄË¶ÅÊ∑±Ëâ≤)
        const COLORS = { 
            green: 0x22dd88, // ‰∫ÆÁªøÂÖâ
            gold: 0xffeb3b,  // ÊöñÈªÑÂÖâ
            white: 0xffffff, // Á∫ØÁôΩÂÖâ
            red: 0xff3333    // ‰∫ÆÁ∫¢ÂÖâ
        };
        const STATE = { CONVERGED: 'converged', SCATTERED: 'scattered', ZOOMED: 'zoomed' };

        let currentState = STATE.CONVERGED;
        let photos = []; 
        let photoTextures = []; 
        
        let scene, camera, renderer, composer;
        let particlesMesh, snowSystem, photoGroup = new THREE.Group();
        let dummy = new THREE.Object3D();
        let particleData = [];
        let animState = { ratio: 0 }; 

        // Vision
        let handCamera, lastGesture = 'none', gestureDebounce = 0;
        let rotationTarget = { x: 0, y: 0 };

        window.onload = () => {
            initThree();
            initObjects();
            initMediaPipe();
            
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 800);
                transitionToTree();
            }, 1500);

            document.getElementById('photo-upload').addEventListener('change', handlePhotoUpload);
        };

        // --- Photo Logic (Same as before) ---
        async function handlePhotoUpload(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            const btn = document.querySelector('.upload-btn');
            const originalText = btn.innerText;
            btn.innerText = "Processing...";

            photoTextures = [];
            const promises = files.map(file => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            tex.needsUpdate = true;
                            tex.minFilter = THREE.LinearFilter;
                            resolve({ texture: tex, ratio: img.width / img.height });
                        };
                    };
                    reader.readAsDataURL(file);
                });
            });

            try {
                photoTextures = await Promise.all(promises);
                createPhotoMeshes(); 
                updateStatus(`Uploaded ${photoTextures.length} Photos`);
            } catch(err) {
                console.error(err);
                updateStatus("Upload Error");
            } finally {
                btn.innerText = "Upload Photos";
            }
        }

        function createPhotoMeshes() {
            while(photoGroup.children.length > 0) {
                const m = photoGroup.children[0];
                if(m.geometry) m.geometry.dispose();
                if(m.material) m.material.dispose();
                photoGroup.remove(m);
            }
            photos = [];
            const count = photoTextures.length > 0 ? photoTextures.length : 6;
            
            for(let i = 0; i < count; i++) {
                let width = 5, height = 3.5;
                let mat;

                if (photoTextures.length > 0) {
                    const data = photoTextures[i]; 
                    const area = 18; 
                    width = Math.sqrt(area * data.ratio);
                    height = width / data.ratio;

                    // Matte Material for photos (No reflection)
                    mat = new THREE.MeshStandardMaterial({ 
                        map: data.texture, 
                        side: THREE.DoubleSide,
                        roughness: 1.0,  
                        metalness: 0.0,  
                        emissive: 0x000000,
                        color: 0xffffff
                    });
                } else {
                    mat = new THREE.MeshBasicMaterial({ 
                        color: COLORS.gold, 
                        side: THREE.DoubleSide, 
                        transparent: true, opacity: 0.5 
                    });
                }

                const geometry = new THREE.PlaneGeometry(width, height);
                const mesh = new THREE.Mesh(geometry, mat);

                if(photoTextures.length > 0) {
                    const borderGeo = new THREE.PlaneGeometry(width + 0.25, height + 0.25);
                    const borderMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
                    const border = new THREE.Mesh(borderGeo, borderMat);
                    border.position.z = -0.02;
                    mesh.add(border);
                }

                const yPos = count === 1 ? 0 : -10 + (i / (count - 1)) * 20;
                const angle = i * 2.5; 
                
                mesh.userData = {
                    scatterPos: { x: (Math.random()-0.5)*45, y: (Math.random()-0.5)*45, z: (Math.random()-0.5)*25 },
                    treePos: { x: Math.cos(angle) * 11, y: yPos, z: Math.sin(angle) * 11 }
                };
                
                const p = mesh.userData.treePos;
                mesh.position.set(p.x, p.y, p.z);
                photoGroup.add(mesh);
                photos.push(mesh);
            }
        }

        // --- Three.js Setup ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // Ëâ≤Ë∞ÉÊò†Â∞ÑËÆæ‰∏∫ Linear ‰ª•Ëé∑ÂæóÊõ¥Á∫ØÁ≤πÁöÑÂèëÂÖâÊÑü
            renderer.toneMapping = THREE.LinearToneMapping;
            document.body.appendChild(renderer.domElement);

            // Light (Still needed for photos)
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            const mainLight = new THREE.PointLight(0xffffff, 1.0, 100);
            mainLight.position.set(10, 15, 20);
            scene.add(mainLight);

            // Bloom - Adjusted for "Glowing Lights"
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; // ÈòàÂÄºÈôç‰ΩéÔºåËÆ©Â∞èÁÇπÊõ¥ÂÆπÊòìÂèëÂÖâ
            bloomPass.strength = 1.2;  // Âº∫Â∫¶Â¢ûÂä†
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            scene.add(photoGroup);
        }

        function initObjects() {
            // Snow
            const snowGeo = new THREE.BufferGeometry();
            const snowPos = [];
            const snowVels = [];
            for(let i=0; i<SNOW_COUNT; i++) {
                snowPos.push((Math.random()-0.5)*100, Math.random()*60-20, (Math.random()-0.5)*60);
                snowVels.push(Math.random()*0.05 + 0.02);
            }
            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
            snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent:true, opacity:0.6}));
            snowSystem.userData = { vels: snowVels };
            scene.add(snowSystem);

            // --- Tree Particles (Glowing Dots) ---
            // ‰ΩøÁî® BasicMaterial (‰∏çÂèóÂÖâÁÖßÂΩ±ÂìçÔºåËá™ÂèëÂÖâ)
            const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            // ‰ΩøÁî®ÊûÅÂ∞èÁöÑ Sphere Ê®°Êãü LED ÁÅØÁè†
            const geometry = new THREE.SphereGeometry(0.06, 8, 8);
            
            particlesMesh = new THREE.InstancedMesh(geometry, pMat, PARTICLE_COUNT);
            scene.add(particlesMesh);
            
            const color = new THREE.Color();
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const angle = i * 0.15; // Êõ¥Á¥ßÂØÜÁöÑËû∫Êóã
                const h = (i/PARTICLE_COUNT)*35 - 15;
                const r = (1 - i/PARTICLE_COUNT)*14;
                
                // ÁªôÊ†ëÂ¢ûÂä†‰∏Ä‰∫õÈöèÊú∫ÊäñÂä®ÔºåËÆ©ÂÆÉÁúãËµ∑Êù•‰∏çÂÉèÂÆåÁæéÁöÑÂúÜÈî•ÔºåÊõ¥Ëá™ÁÑ∂
                const jitterX = (Math.random() - 0.5) * 0.5;
                const jitterZ = (Math.random() - 0.5) * 0.5;

                particleData.push({
                    tree: { x: Math.cos(angle)*r + jitterX, y: h, z: Math.sin(angle)*r + jitterZ },
                    scatter: { x: (Math.random()-0.5)*60, y: (Math.random()-0.5)*60, z: (Math.random()-0.5)*60 }
                });
                
                // Color Distribution for Lights
                const rand = Math.random();
                if(rand < 0.4) color.setHex(COLORS.green); 
                else if(rand < 0.7) color.setHex(COLORS.gold); 
                else if(rand < 0.9) color.setHex(COLORS.red);
                else color.setHex(COLORS.white);
                
                particlesMesh.setColorAt(i, color);
            }

            createPhotoMeshes(); 
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // Snow
            const sp = snowSystem.geometry.attributes.position.array;
            const sv = snowSystem.userData.vels;
            for(let i=0; i<SNOW_COUNT; i++) {
                sp[i*3+1] -= sv[i];
                sp[i*3] += Math.sin(time+i)*0.02;
                if(sp[i*3+1] < -30) sp[i*3+1] = 30;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            // Scene Rotation
            if (currentState === STATE.CONVERGED) {
                scene.rotation.y += 0.002;
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, 0, 0.05);
            } else if (currentState === STATE.SCATTERED) {
                scene.rotation.y = THREE.MathUtils.lerp(scene.rotation.y, rotationTarget.y, 0.1);
                scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, rotationTarget.x, 0.1);
            }

            // Particles Update
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const d = particleData[i];
                const r = animState.ratio;
                dummy.position.set(
                    THREE.MathUtils.lerp(d.tree.x, d.scatter.x, r),
                    THREE.MathUtils.lerp(d.tree.y, d.scatter.y, r),
                    THREE.MathUtils.lerp(d.tree.z, d.scatter.z, r)
                );
                
                // Twinkle Effect (Scaling)
                // Âú® Converged Áä∂ÊÄÅ‰∏ãÈó™ÁÉÅÔºåÂú® Scattered Áä∂ÊÄÅ‰∏ãÂèòÂ§ß‰∏ÄÁÇπ
                const twinkle = currentState === STATE.CONVERGED ? 0.8 + Math.sin(time * 3 + i * 0.5) * 0.4 : 1.0;
                dummy.scale.setScalar(twinkle);
                
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // Photos
            if (currentState !== STATE.ZOOMED) {
                photos.forEach(p => {
                    const t = p.userData.treePos, s = p.userData.scatterPos;
                    p.position.x = THREE.MathUtils.lerp(t.x, s.x, animState.ratio);
                    p.position.y = THREE.MathUtils.lerp(t.y, s.y, animState.ratio);
                    p.position.z = THREE.MathUtils.lerp(t.z, s.z, animState.ratio);
                    p.lookAt(camera.position);
                });
            }

            composer.render();
        }

        animate();

        // --- Transitions ---
        function transitionToTree() {
            if (currentState === STATE.CONVERGED) return;
            currentState = STATE.CONVERGED;
            updateStatus("Mode: Glowing Tree");
            gsap.to(animState, { ratio: 0, duration: 1.5, ease: "power2.inOut" });
            photos.forEach(p => gsap.to(p.scale, {x:1, y:1, z:1, duration: 1}));
        }

        function transitionToScatter() {
            if (currentState === STATE.SCATTERED) return;
            currentState = STATE.SCATTERED;
            updateStatus("Mode: Starry Sky");
            gsap.to(animState, { ratio: 1, duration: 2, ease: "elastic.out(1, 0.5)" });
            photos.forEach(p => gsap.to(p.scale, {x:1, y:1, z:1, duration: 1}));
        }

        function transitionToZoom() {
            if (currentState === STATE.ZOOMED || photos.length === 0) return;
            currentState = STATE.ZOOMED;
            updateStatus("Mode: Precious Memory");
            const target = photos[Math.floor(Math.random()*photos.length)];
            gsap.to(target.position, { x: -camera.position.x*0.1, y: camera.position.y, z: camera.position.z-8, duration: 1.2, ease: "back.out(1.5)" });
            gsap.to(target.rotation, { x:0, y:0, z:0, duration: 1.2 });
            gsap.to(target.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 1.2 });
        }

        function updateStatus(t) {
            const el = document.getElementById('gesture-status');
            el.innerText = t;
            el.style.transform = "scale(1.2)";
            setTimeout(() => el.style.transform = "scale(1)", 200);
        }

        // --- MediaPipe ---
        function initMediaPipe() {
            const vid = document.getElementById('cam-preview');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(res => {
                if(!res.multiHandLandmarks?.length) return;
                const lm = res.multiHandLandmarks[0];
                
                const fist = lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y;
                const open = lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y < lm[14].y;
                const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.04;

                let g = 'none';
                if(pinch) g='pinch'; else if(fist) g='fist'; else if(open) g='open';

                if(g === lastGesture) gestureDebounce++; else { gestureDebounce=0; lastGesture=g; }
                if(gestureDebounce > 8) {
                    if(g === 'fist') transitionToTree();
                    else if(g === 'open' && currentState !== STATE.SCATTERED) transitionToScatter();
                    else if(g === 'pinch') transitionToZoom();
                }
                if(currentState === STATE.SCATTERED && g === 'open') {
                    rotationTarget.y = (lm[0].x - 0.5) * 3;
                    rotationTarget.x = (lm[0].y - 0.5) * 2;
                }
            });
            handCamera = new Camera(vid, { onFrame: async () => await hands.send({image: vid}), width: 320, height: 240 });
            handCamera.start();
        }
    </script>
</body>
</html>
